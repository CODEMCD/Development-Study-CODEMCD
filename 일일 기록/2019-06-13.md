# 2019-06-13 일기

- [프론트엔드 네이버 컨벤션](https://nuli.navercorp.com/data/convention/NHN_Coding_Conventions_for_Markup_Languages.pdf)

## 데이터베이스에서 프라이머리키는 반드시 만들어야한다.
- 프라이머리 키가 없다면, 일관성 없는 데이터가 계속 쌓일 수 있기 때문에, 쿼리 속도가 느리고 원하지 않는 정보 조회 결과를 얻을 수 있다.
- 프라이머리키를 만들면 자동으로 클러스터드 인덱스를 만들어준다.
- 클러스터드 인덱스는 검색속도가 빠른 인덱스 방법이며, 대신 삽입/삭제 연산이 느리다.
- 프라이머리키를 만들지 않으면 mysql은 자동으로 유니크한 키를 만들어 클러스터드 인덱싱을 한다.

## 인덱스란?
- 인덱스는 디스크 구조로, 책 뒤편의 찾아보기와 유사하다.
- 클러스터드 인덱스, 비클러스터드 인덱스, 힙 인덱스 등이 있다.
- 비클러스터드 인덱스는 여러 열에 있을 수 있고, 검색 속도가 클러스터드 인덱스에 비해 느리지만, 삽입/삭제 속도는 빠르다.

## 데이터베이스에서 close를 안하면?
- <https://kldp.org/node/151024>
php 는 page 종료가 될때 GC(gabage collector)에 의해서 모든 reousrce를 반환하도록 되어 있습니다. 즉 mysql open은 page가 종료되는 시점에서 자동으로 close가 됩니다.
그럼 왜 close를 해야 하느냐에 대한 의문이 남을 수 있는데

1. connection을 끊고 다른 connection을 사용하고 싶을 때
2. 시간이 긴 page 처리에서, db connection 이 전반부에서만 사용될 때의 resource 중복 낭비를 위해서..
이정도로 보시면 됩니다. 즉, 처리하는 page의 속도가 아주 빠르다거나, 또는 resource 사용량이 많지 않다면 굳이 close를 하지 않아도 상관은 없습니다만, 이건 일반적인 견해이고, logic에 따라 close를 해 주시는 것이 더 효율적일 수 있습니다. 다만 이 효율이라는 것이 resource 관점일 뿐, 다른 비용을 추가했을 경우에는 close에 신경을 쓰는 것이 더 비효율적일 수도 있습니다.

## git commit --amend를 취소하고 싶을 때
- 이를 사용한 상황은 푸쉬된 커밋에 amend를 한 경우이다.
- amend commit으로 실수로 덮어쓴 경우에는 git reset --soft 'HEAD@{1}' 으로 undo 시키고 다시 커밋을 한다.

## SQL 강의
- 강의 링크: <https://www.youtube.com/watch?v=TRfVeco4wZM>
- 데이터베이스는 테이블 인덱스, 뷰 등이 있다.
- insert Query를 날리면 테이블이 아닌 페이지에 기록된다.
- 페이지는 8KB의 고정된 크기를 가지고 있으며, 레코드가 저장된다.(레코드는 테이블의 한 튜플)
- 페이지 내의 행이 많아야 I/O 호출이 적다.
- 인덱스는 "빨리 빨리"를 위해 만들어졌다.(검색속도를 위함)
- 페이지를 가지는 것은 테이블과 인덱스뿐이다. 그러므로 인덱스를 사용하면 메모리가 많이 든다.
- 테이블은 기본적으로 힙으로 저장되어 있다.
- 힙은 순서가 없는 데이터이다.
- 인덱스가 빠른 이유는 정렬때문이다.
- 힙은 insert 하기 좋다.
- select를 위한 테이블, insert를 위한 테이블을 구분하는 것이 중요하다.
- 힙에서 데이터를 찾는 방법은 처음부터 하나하나 살펴보는 것 뿐이다.(Table Scan)
- 클러스터드 인덱스는 데이터를 가지고 있고 정렬된 데이터이다.
  - 특정 열이나 열들을 기준으로 데이터가 논리적인 정렬을 이룬다.
  - 테이블당 하나의 클러스터드 인덱스를 가질 수 있다.
  - Clustered Index Seek: Root 페이지부터 찾아간다. 매우 빠름
  - Clustered Index Scan: 모든 테이블을 다 읽는다. Table Scan과 유사
  - 유니크를 지정한다.(없으면 값을 할당한다.)
