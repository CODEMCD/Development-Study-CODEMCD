# [백준]6064번 카잉 달력

## 풀이 전략
- 빠르게 최소공배수 구하기

**유클리드 호제법** 을 사용하면 최소공배수를 빠르게 구할 수 있다. 유클리드 호제법은 최대공약수를 간단히 구하는 방법인데, 최대공약수를 알면 최소공배수 역시 바로 구할 수 있다.

### 유클리드 호제법
- 참고 링크: <https://www.youtube.com/watch?v=J5Yl2kHPAY4>

위 영상은 유클리드 호제법을 증명하는 영상이다. 간단히 말하면 A, B 사이의 최대공약수가 G라고 할 때, ```A % B = R```에서 R과 B 사이의 최대공약수 역시 G이다. 이를 코드로 나타내면 다음과 같다.

```cpp
int CalculateGCD(int m, int n)
{
  int r = m % n;
  if (r == 0) return n;
  else return CalculateGCD(n, r);
}
```

최대공약수를 구했다면, 최소공배수는 바로 아래와 같이 구할 수 있다.

```cpp
int CalculateLCM(int m, int n)
{
  return (m * n) / CalculateGCD(m, n);
}
```

- 빠르게 일치하는 해 찾기

먼저 해쉬를 사용한 ```unordered_set```을 사용해서 첫 번째 가능 연도를 모두 set자료구조에 넣고, 두 번째 연도를 하나하나 반복하면서 set에 있는지 검사했다. 해쉬를 쓰기 때문에 빠르게 찾을 수 있다고 생각했는데, 예상 외로 많은 시간이 걸렸다. 1초는 걸리지 않았지만 대략 800ms이나 걸렸다.

다른 방법으로는 첫 번째 가능 연도만으로 두 번째 연도를 바로 계산하는 방법이다. <https://jaimemin.tistory.com/808> 해당 링크를 참조했는데, 완전히 이해는 되지 않았다. 문제에서는 모듈러 연산을 1 ~ N까지 계산하고 있기 때문에 이를 맞춰줘야 모든 케이스를 맞출 수 있다고 한다.
